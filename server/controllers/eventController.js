import { Event, Team } from "../models/index.js";

/**
 * Create new event
 * @route POST /api/events
 * @access Organizer/Admin only
 */
export const createEvent = async (req, res) => {
  try {
    const {
      name,
      slug,
      description,
      type,
      startDate,
      endDate,
      venue,
      registrationFeePerMember,
      maxTeamSize,
      minTeamSize,
      maxTeams,
      registrationOpen,
      isActive,
    } = req.body;

    // Validate required fields
    if (!name || !slug || !description || !startDate || !endDate || !venue) {
      return res.status(400).json({
        success: false,
        error:
          "Please provide name, slug, description, startDate, endDate, and venue",
      });
    }

    // Normalize slug to lowercase
    const normalizedSlug = slug.toLowerCase();

    // Check if event with same slug already exists (case-insensitive)
    const existingEvent = await Event.findOne({ slug: normalizedSlug });
    if (existingEvent) {
      return res.status(409).json({
        success: false,
        error: "Event with this slug already exists",
      });
    }

    // Validate date formats
    const start = new Date(startDate);
    const end = new Date(endDate);

    if (isNaN(start.getTime())) {
      return res.status(400).json({
        success: false,
        error: "Invalid start date format",
      });
    }

    if (isNaN(end.getTime())) {
      return res.status(400).json({
        success: false,
        error: "Invalid end date format",
      });
    }

    // Validate date logic
    if (end <= start) {
      return res.status(400).json({
        success: false,
        error: "End date must be after start date",
      });
    }

    // Validate team size logic if provided
    if (maxTeamSize && minTeamSize && maxTeamSize < minTeamSize) {
      return res.status(400).json({
        success: false,
        error:
          "Maximum team size must be greater than or equal to minimum team size",
      });
    }

    // Create event (canteen QR token will be auto-generated by pre-save hook)
    const event = await Event.create({
      name,
      slug: normalizedSlug,
      description,
      type,
      startDate,
      endDate,
      venue,
      registrationFeePerMember,
      maxTeamSize,
      minTeamSize,
      maxTeams,
      registrationOpen,
      isActive,
    });

    return res.status(201).json({
      success: true,
      data: {
        event,
      },
    });
  } catch (error) {
    console.error("Create event error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error creating event",
    });
  }
};

/**
 * Get all events with filtering and pagination
 * @route GET /api/events
 * @access All authenticated users
 */
export const getAllEvents = async (req, res) => {
  try {
    // Build query object from query parameters
    const query = {};

    // Filter by type
    if (req.query.type) {
      query.type = req.query.type;
    }

    // Filter by isActive
    if (req.query.isActive !== undefined) {
      query.isActive = req.query.isActive === "true";
    }

    // Filter by registrationOpen
    if (req.query.registrationOpen !== undefined) {
      query.registrationOpen = req.query.registrationOpen === "true";
    }

    // Search by name (case-insensitive)
    if (req.query.search) {
      query.name = { $regex: req.query.search, $options: "i" };
    }

    // Pagination
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    // Get total count for pagination metadata
    const total = await Event.countDocuments(query);

    // Fetch events with pagination and sorting (exclude canteenQRToken)
    const events = await Event.find(query)
      .select("-canteenQRToken")
      .sort({ createdAt: -1 })
      .limit(limit)
      .skip(skip);

    // Calculate total pages
    const totalPages = Math.ceil(total / limit);

    return res.status(200).json({
      success: true,
      data: {
        events,
        pagination: {
          page,
          limit,
          total,
          totalPages,
        },
      },
    });
  } catch (error) {
    console.error("Get all events error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error fetching events",
    });
  }
};

/**
 * Get single event by ID or slug
 * @route GET /api/events/:id
 * @access All authenticated users
 */
export const getEventById = async (req, res) => {
  try {
    const { id } = req.params;

    let event;

    // Try to find by ID first (exclude canteenQRToken)
    if (id.match(/^[0-9a-fA-F]{24}$/)) {
      event = await Event.findById(id).select("-canteenQRToken");
    }

    // If not found by ID, try to find by slug (exclude canteenQRToken)
    if (!event) {
      event = await Event.findOne({ slug: id }).select("-canteenQRToken");
    }

    // Return 404 if event not found
    if (!event) {
      return res.status(404).json({
        success: false,
        error: "Event not found",
      });
    }

    return res.status(200).json({
      success: true,
      data: {
        event,
      },
    });
  } catch (error) {
    console.error("Get event by ID error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error fetching event",
    });
  }
};

/**
 * Update event
 * @route PATCH /api/events/:id
 * @access Organizer/Admin only
 */
export const updateEvent = async (req, res) => {
  try {
    const { id } = req.params;

    // Prevent updating canteenQRToken directly (security measure)
    if (req.body.canteenQRToken) {
      return res.status(400).json({
        success: false,
        error: "Canteen QR token cannot be updated directly",
      });
    }

    // Find event
    const event = await Event.findById(id);

    if (!event) {
      return res.status(404).json({
        success: false,
        error: "Event not found",
      });
    }

    // Normalize slug to lowercase if being updated
    let normalizedSlug = req.body.slug;
    if (normalizedSlug) {
      normalizedSlug = normalizedSlug.toLowerCase();
    }

    // Validate slug uniqueness if slug is being updated (case-insensitive)
    if (normalizedSlug && normalizedSlug !== event.slug) {
      const existingEvent = await Event.findOne({ slug: normalizedSlug });
      if (existingEvent) {
        return res.status(409).json({
          success: false,
          error: "Event with this slug already exists",
        });
      }
    }

    // Validate date formats and logic if dates are being updated
    let startDate = event.startDate;
    let endDate = event.endDate;

    if (req.body.startDate) {
      startDate = new Date(req.body.startDate);
      if (isNaN(startDate.getTime())) {
        return res.status(400).json({
          success: false,
          error: "Invalid start date format",
        });
      }
    }

    if (req.body.endDate) {
      endDate = new Date(req.body.endDate);
      if (isNaN(endDate.getTime())) {
        return res.status(400).json({
          success: false,
          error: "Invalid end date format",
        });
      }
    }

    if (endDate <= startDate) {
      return res.status(400).json({
        success: false,
        error: "End date must be after start date",
      });
    }

    // Validate team size logic if team sizes are being updated
    const maxTeamSize =
      req.body.maxTeamSize !== undefined
        ? req.body.maxTeamSize
        : event.maxTeamSize;
    const minTeamSize =
      req.body.minTeamSize !== undefined
        ? req.body.minTeamSize
        : event.minTeamSize;

    if (maxTeamSize < minTeamSize) {
      return res.status(400).json({
        success: false,
        error:
          "Maximum team size must be greater than or equal to minimum team size",
      });
    }

    // Update fields
    const allowedUpdates = [
      "name",
      "description",
      "type",
      "startDate",
      "endDate",
      "venue",
      "registrationFeePerMember",
      "maxTeamSize",
      "minTeamSize",
      "maxTeams",
      "registrationOpen",
      "isActive",
    ];

    allowedUpdates.forEach((field) => {
      if (req.body[field] !== undefined) {
        event[field] = req.body[field];
      }
    });

    // Handle slug separately with normalized value
    if (normalizedSlug) {
      event.slug = normalizedSlug;
    }

    // Save event (triggers validators and middleware)
    await event.save();

    return res.status(200).json({
      success: true,
      data: {
        event,
      },
    });
  } catch (error) {
    console.error("Update event error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error updating event",
    });
  }
};

/**
 * Delete event
 * @route DELETE /api/events/:id
 * @access Organizer/Admin only
 */
export const deleteEvent = async (req, res) => {
  try {
    const eventId = req.params.id;

    // find event
    const event = await Event.findById(eventId);
    if (!event) {
      return res.status(404).json({
        success: false,
        error: "Event not found",
      });
    }

    // find team assosiated with the event
    const teams = await Team.find({ eventId });

    // delete the teams
    for (const team of teams) {
      await team.deleteOne();
    }

    // delete the event
    const deletedEvent = await Event.findByIdAndDelete(eventId);

    return res.status(200).json({
      success: true,
      message: "Event and associated teams deleted successfully",
      data: {
        deletedEvent,
        deletedTeamsCount: teams.length,
      },
    });
  } catch (error) {
    console.error("Delete event error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error deleting event",
    });
  }
};

/**
 * Get event canteen QR code
 * @route GET /api/events/:id/canteen-qr
 * @access Organizer/Admin only
 */
export const getEventCanteenQR = async (req, res) => {
  try {
    const { id } = req.params;

    // Query event including canteenQRToken (which is excluded by default)
    const event = await Event.findById(id).select("+canteenQRToken");

    if (!event) {
      return res.status(404).json({
        success: false,
        error: "Event not found",
      });
    }

    // Return basic event info with canteen QR token
    return res.status(200).json({
      success: true,
      data: {
        _id: event._id,
        name: event.name,
        slug: event.slug,
        venue: event.venue,
        startDate: event.startDate,
        endDate: event.endDate,
        isActive: event.isActive,
        registrationOpen: event.registrationOpen,
        canteenQRToken: event.canteenQRToken,
      },
    });
  } catch (error) {
    console.error("Get event canteen QR error:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Error fetching event canteen QR",
    });
  }
};
